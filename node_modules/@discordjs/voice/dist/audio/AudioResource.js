"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAudioResource = exports.inferStreamType = exports.NO_CONSTRAINT = exports.VOLUME_CONSTRAINT = exports.AudioResource = void 0;
const TransformerGraph_1 = require("./TransformerGraph");
const stream_1 = require("stream");
const util_1 = require("../util/util");
const prism_media_1 = require("prism-media");
/**
 * Represents an audio resource that can be played by an audio player.
 *
 * @template T - the type for the metadata (if any) of the audio resource.
 */
class AudioResource {
    constructor(edges, streams, metadata) {
        /**
         * The playback duration of this audio resource, given in milliseconds.
         */
        this.playbackDuration = 0;
        /**
         * Whether or not the stream for this resource has started (data has become readable)
         */
        this.started = false;
        this.edges = edges;
        this.playStream = streams.length > 1 ? stream_1.pipeline(streams, util_1.noop) : streams[0];
        this.metadata = metadata;
        for (const stream of streams) {
            if (stream instanceof prism_media_1.VolumeTransformer) {
                this.volume = stream;
            }
            else if (stream instanceof prism_media_1.opus.Encoder) {
                this.encoder = stream;
            }
        }
        stream_1.once(this.playStream, 'readable')
            .then(() => (this.started = true))
            .catch(util_1.noop);
    }
    /**
     * Attempts to read an Opus packet from the audio resource. If a packet is available, the playbackDuration
     * is incremented.
     * @internal
     * @remarks
     * It is advisable to check that the playStream is readable before calling this method. While no runtime
     * errors will be thrown, you should check that the resource is still available before attempting to
     * read from it.
     */
    read() {
        const packet = this.playStream.read();
        if (packet) {
            this.playbackDuration += 20;
        }
        return packet;
    }
}
exports.AudioResource = AudioResource;
/**
 * Ensures that a path contains at least one volume transforming component
 *
 * @param path - The path to validate constraints on
 */
const VOLUME_CONSTRAINT = (path) => path.some((edge) => edge.type === TransformerGraph_1.TransformerType.InlineVolume);
exports.VOLUME_CONSTRAINT = VOLUME_CONSTRAINT;
const NO_CONSTRAINT = () => true;
exports.NO_CONSTRAINT = NO_CONSTRAINT;
/**
 * Tries to infer the type of a stream to aid with transcoder pipelining.
 *
 * @param stream - The stream to infer the type of
 */
function inferStreamType(stream) {
    if (stream instanceof prism_media_1.opus.Encoder) {
        return { streamType: TransformerGraph_1.StreamType.Opus, hasVolume: false };
    }
    else if (stream instanceof prism_media_1.opus.Decoder) {
        return { streamType: TransformerGraph_1.StreamType.Raw, hasVolume: false };
    }
    else if (stream instanceof prism_media_1.VolumeTransformer) {
        return { streamType: TransformerGraph_1.StreamType.Raw, hasVolume: true };
    }
    else if (stream instanceof prism_media_1.opus.OggDemuxer) {
        return { streamType: TransformerGraph_1.StreamType.Opus, hasVolume: false };
    }
    else if (stream instanceof prism_media_1.opus.WebmDemuxer) {
        return { streamType: TransformerGraph_1.StreamType.Opus, hasVolume: false };
    }
    return { streamType: TransformerGraph_1.StreamType.Arbitrary, hasVolume: false };
}
exports.inferStreamType = inferStreamType;
/**
 * Creates an audio resource that can be played be audio players.
 *
 * @remarks
 * If the input is given as a string, then the inputType option will be overridden and FFmpeg will be used.
 *
 * If the input is not in the correct format, then a pipeline of transcoders and transformers will be created
 * to ensure that the resultant stream is in the correct format for playback. This could involve using FFmpeg,
 * Opus transcoders, and Ogg/WebM demuxers.
 *
 * @param input - The resource to play.
 * @param options - Configurable options for creating the resource.
 *
 * @template T - the type for the metadata (if any) of the audio resource.
 */
function createAudioResource(input, options = {}) {
    var _a, _b;
    let inputType = options.inputType;
    let needsInlineVolume = Boolean(options.inlineVolume);
    // string inputs can only be used with FFmpeg
    if (typeof input === 'string') {
        inputType = TransformerGraph_1.StreamType.Arbitrary;
    }
    else if (typeof inputType === 'undefined') {
        const analysis = inferStreamType(input);
        inputType = analysis.streamType;
        needsInlineVolume = needsInlineVolume && !analysis.hasVolume;
    }
    const transformerPipeline = TransformerGraph_1.findPipeline(inputType, needsInlineVolume ? exports.VOLUME_CONSTRAINT : exports.NO_CONSTRAINT);
    if (transformerPipeline.length === 0) {
        if (typeof input === 'string')
            throw new Error(`Invalid pipeline constructed for string resource '${input}'`);
        // No adjustments required
        return new AudioResource([], [input], ((_a = options.metadata) !== null && _a !== void 0 ? _a : null));
    }
    const streams = transformerPipeline.map((edge) => edge.transformer(input));
    if (typeof input !== 'string')
        streams.unshift(input);
    return new AudioResource(transformerPipeline, streams, ((_b = options.metadata) !== null && _b !== void 0 ? _b : null));
}
exports.createAudioResource = createAudioResource;
//# sourceMappingURL=AudioResource.js.map